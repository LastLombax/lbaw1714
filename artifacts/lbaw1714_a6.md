# A6: Indexes, triggers, user functions and population

 GROUP1714, 01/04/2018

* Daniel Ribeiro de Pinho - up201505302@fe.up.pt

* Francisco José Sousa Silva - up201502860@fe.up.pt

* Rui André Rebolo Fernandes Leixo - up201504818@fe.up.pt

* Vitor Emanuel Fernandes Magalhães - up201503447@fe.up.pt
 
## 1. Database Workload
 
### 1.1. Tuple Estimation
 
| Relation reference | Relation Name | Order of magnitude        | Estimated growth |
| ------------------ | ------------- | ------------------------- | ---------------- |
| R01                | Comment        | thousands | dozens per day   |
| R02                | Community        | hundreds | units per week |
| R03                | CommunityCategory        | tens | no growth |
| R04                | Community_CommunityCategory    | tens | units per week   |
| R05                | Community_Member        | tens | units per day    |
| R06                | Event        | thousands | units per day   |
| R07                | EventCategory         | tens | no growth |
| R08                | Event_EventCategory         | tens | units per day   |
| R09                | Event_Member         | thousands | units per day    |
| R10                | Friend        | hundreds | dozens per week |
| R11                | Invoice        | hundreds | dozens per week  |
| R12                | Member        | thousands | units per day      |
| R13                | Notification        | thousands | dozens per day        |
| R14                | Report        | tens | units per week   |
| R15                | Ticket        | hundreds | units per week       |
| R16                | TicketType        | hundreds | units per week       |


 
### 1.2. Frequent Queries
 
> Most important queries (SELECT) and their frequency.

<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT01</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td>User Profile Information</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql
SELECT name, username, birthdate, email, country, city, address, taxPayerNumber, about, profilePicture, registrationDate
FROM "Member"
WHERE "Member".idMember = $_SESSION["currentMember"];
```

//CHECK ABOUT ACTIVITY FEED
<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT02</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Member's Activity Feed</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql

```

<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT03</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Member's Upcoming Events</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql
SELECT name, description, imagePath, date
FROM "event"
INNER JOIN event_member 
ON event.idevent= event_member.idevent AND "event_member".idmember = $_SESSION["currentMember"]
WHERE "event".date >= $today
Order BY "event".date
LIMIT 3
OFFSET 3 /* OFFSET skips rows. For pagination, it will be OFFSET 3*($currentPage -1) */
```

buscar bilhete de um upcoming event do membro;
<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT04</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Ticket from an Upcoming Event of a Member</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per month</td>
 </tr>  
</table>

```sql
SELECT *
FROM "TicketType"
WHERE "TicketType".event = $selectedEvent
AND "Ticket".buyer = $_SESSION["currentMember"]

```

ver evento;
<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT05</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Event's Information</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql
SELECT name, description, imagePath, date, country, city, address
FROM "event"
WHERE "event".idEvent = $selectedEvent;
```

ver comentarios(activity feed?) do evento;
<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT06</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Event's Information</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql

```

get top events;
<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT07</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Get top Events</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql
SELECT name, imagePath, date, description
FROM "event" e1
INNER JOIN LATERAL 
(
SELECT COUNT("idmember") as numberMembers
FROM "event_member"
WHERE "event_member".idevent= e1.idevent
) e2 ON true
ORDER BY numberMembers DESC
```

ver comunidade;
<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT08</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Community's Information</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>dozens per day</td>
 </tr>  
</table>

```sql
SELECT name, description, imagePath, creationDate, numberMembers
FROM "community" c1
INNER JOIN LATERAL 
(
SELECT COUNT("idmember") as numberMembers
FROM "community_member"
WHERE "community_member".idcommunity= c1.idcommunity
) c2 ON true
WHERE c1.idcommunity = $selectedCommunity;

/*administrators, categories and members vão ter de se buscar pelo CommunityCategory e Communitymember*/
/* Faltam admins e categorias*/
```

ver activity feed da comunidade;
<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT09</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Event's Information</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql

```

<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT10</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Get top Communities</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql
SELECT name, description, imagePath, creationDate, numberMembers
FROM "community" c1
INNER JOIN LATERAL 
(
SELECT COUNT("idmember") as numberMembers
FROM "community_member"
WHERE "community_member".idcommunity= c1.idcommunity
) e2 ON true
ORDER BY numberMembers DESC
LIMIT 1
/* we can limit them with the LIMIT*/
```

<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT11</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Visitor's Upcoming Events</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql
SELECT name, description, imagePath, date
FROM "event"
WHERE "event".date >= $today
Order BY "event".date
LIMIT 4
```

paginação do feed de cada;
ver 7 notificações mais recentes;

<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT12</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Member's joined Events</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql
SELECT name, description, imagePath, date
FROM "event", "event_member", "member"
WHERE "event".idevent = "event_member".idevent AND "event_member".idmember = "member".idmember AND "event".date >= $today
Order BY "event".date
LIMIT 4
```

<table>
 <tr>
  <td><strong>Query Reference</strong></td>
  <td>SELECT13</td>
   </tr>
   <tr>
   <td><strong>Query Description</strong></td>
   <td> Member's joined Communities</td>
   </tr>
  <tr>
  <td><strong>Query Frequency</strong></td>
  <td>hundreds per day</td>
 </tr>  
</table>

```sql
SELECT name, description, imagePath, creationDate, numberMembers
FROM "community" c1, "community_member", "member" WHERE "community_member".idcommunity = c1.idcommunity 
AND "community_member".idmember = "member".idmember
INNER JOIN LATERAL 
(
SELECT COUNT("idmember") as numberMembers
FROM "community_member"
WHERE "community_member".idcommunity= c1.idcommunity
) e2 ON true
ORDER BY numberMembers DESC
LIMIT 1
/* we can limit them with the LIMIT*/
```

paginação do feed de cada;
ver 7 notificações mais recentes;
 
### 1.3. Frequent Updates
 
> Most important updates (INSERT, UPDATE, DELETE) and their frequency.
 
| Query reference   | UPDATE01                               |
| Query description | One sentence describing the query goal |
| Query frequency   | magnitude per time                     |
| ----------------- | -------------------------------------- |
| SQL code                                                   |
 
 
## 2. Proposed Indices
 
### 2.1. Performance Indices
 
> Indices proposed to improve performance of the identified queries.
 
| Index reference | IDX01                                  |
| Related queries | SELECT01, ...                          |
| Index relation  | Relation where the index is applied    |
| Index attribute | Attribute where the index is applied   |
| Index type      | B-tree, Hash, GiST or GIN              |
| Cardinality     | Attribute cardinality: low/medium/high |
| Clustering      | Clustering of the index                |
| --------------- | -------------------------------------- |
| Justification   | Justification for the proposed index   |
| --------------- | -------------------------------------- |
| SQL code                                                 |
 
 
### 2.2. Full-text Search Indices 
 
> The system being developed must provide full-text search features supported by PostgreSQL. Thus, it is necessary to specify the fields where full-text search will be available and the associated setup, namely all necessary configurations, indexes definitions and other relevant details.
 
| Index reference | IDX01                                  |
| Related queries | SELECT01, ...                          |
| Index relation  | Relation where the index is applied    |
| Index attribute | Attribute where the index is applied   |
| Index type      | B-tree, Hash, GiST or GIN              |
| Clustering      | Clustering of the index                |
| --------------- | -------------------------------------- |
| Justification   | Justification for the proposed index   |
| --------------- | -------------------------------------- |
| SQL code                                                 |
 
 
## 3. Triggers
 
> User-defined functions and trigger procedures that add control structures to the SQL language or perform complex computations, are identified and described to be trusted by the database server. Every kind of function (SQL functions, Stored procedures, Trigger procedures) can take base types, composite types, or combinations of these as arguments (parameters). In addition, every kind of function can return a base type or a composite type. Functions can also be defined to return sets of base or composite values.
 
| Trigger reference   | TRIGGER01                                                               |
| Trigger description | Trigger description, including reference to the business rules involved |
| ------------------- | ----------------------------------------------------------------------- |
| SQL code                                                                                      |
 
 
## 4. Complete SQL Code
 
> The database script must also include the SQL to populate a database with test data with an amount of tuples suitable for testing and with plausible values for the fields of the database.
> This code should also be included in the group's github repository as an SQL script, and a link include here.
 
 
